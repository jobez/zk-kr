- a function is
	- a reusable unit of code
		- that
			- receives
				- arguments
			- returns
				- a value
	- to facilitate this in cairo
		- we introduce two low-level instructions
			- `call addr`
			- `ret`
- declared as follows
	- the lines `func function_name()`
		- are not translated to cairo instructions
		- they are just used by the compiler to
			- name the function
			- create a corresponding scope
	- ```
	  func function_name() {
	  // your code here
	  return ();
	  }
	  ```
- to call the function, simply use the call function
	- `call function_name`
	- `function_name();`
- the full syntax of `call` is similar to `jmp`
	- you can call a label (a function is also considered a label)
	- make a relative or absolute call
- the [[frame pointer]] register
	- when a function starts
		- the frame pointer register
			- is initialized to
				- the current value of [[allocation pointer]]
	- during the entire scope of the function (excluding inner function calls)
		- the value of frame pointer remains constant
	- when a function, foo, calls an inner function, bar
		- the value of frame pointer changes when bar starts but is restored when bar ends
	- the idea is that ap may change in an unknown way when an inner function is called
		- so
			- it cannot reliably be used to acecess the original function's local viarbles and arguments any more after that
		- thus fp serves as an anchor to access these values
- execises
	- ```
	  func main() {
	      call foo;
	      call foo;
	      call foo;
	  
	      ret;
	  }
	  
	  func foo() {
	      [ap] = 1000, ap++;
	      ret;
	  }
	  ```
	- We will analyze the memory generated by this program in the example below. For now, try to think what happens when the cpu gets to the ret instruction (which of the registers ap, fp, pc should change when ret is executed and to what values?).
- under the hood
	- `call addr` is roughly equivalent to the following set of instructions
	- ```
	  // Stores the value of the current fp, which will be
	  // restored once the called function ends using ret.
	  [ap] <-- fp
	  
	  // Stores the address of the next instruction, to run
	  // once the called function ends. This will be
	  // assigned to pc when ret is invoked.
	  [ap + 1] <-- return_pc
	  
	  // Increase ap by 2, to account for the last two writes.
	  ap += 2;
	  
	  // Updates fp to be the new ap, so it points to the start
	  // of the new frame within the called function's scope.
	  fp <-- ap
	  
	  jmp addr;
	  
	  ```
	- ret is roughly equivalent to the following set of instructions
		- ```
		  // Jumps to return_pc (stored on the stack).
		  jmp [fp - 1];
		  
		  // Restores the value of the previous fp.
		  fp <-- [fp - 2]
		  ```
	- we can summarize it thusly
		- call "pushes" the current frame pointer and return-address to a virtual stack of pairs
			- fp, return_pc and jumps to the given address
		- ret "pops"
			- the previous fp and jumps to return_pc that were pushed during the call